Part 1: For the cryptography to work correctly, the server must be trusted with a local key stored in key.pem to verify its certificate. The key is first generated and distributed among our team members so that we all have it locally. The certificate is used by the client to verify the server authenticity.  

Part 2:
- Design: We imported the bcrypt library to hash the passwords. When a new user log in, the passwords are hashed using bcrpyt.hashpw(password.encode(), gensalt()), with gensalt() being a random salt created, and stored. If that user wants to change the password, we hash it again using the same method, and rewrite the newly encrptyed password to the database. If an old user wants to log in, we try to tell if the password is correct by using bcrypt.checkpw(password typed in, password saved).
- We make sure that the server is trusted before hand in part 1.
- A symmetric crypto was used.
- Randomized crypto was not involved.
- Limitation:
    1. Password of length greater than 72 characters are not guaranteed to be hashed correctly, resulting from the limitation of the bcrypt algorithm.
- We talked to Zhanpeng's group about the crypto library they use for this part, which is bcrypt_sha256 from PassLib. They make that decision because in the documentation it says bcrypt itself has some bugs, for example truncating the key length. Since we use bcrypt with such limitation, at first we thought about changing our crypto library. However, passwords are generally a lot shorter than 72 bytes, so we decided to stick to the Python bcrypt library because it is among the best ones to use for hashing passwords, and is generally pretty fast. 

Part 3:
In general, each log file is in the form: randomly generated salt - encrypted log - MAC
- To stop an attacker from reading the file, we encrypt the logs using a symmetric key, generated by hashing a short password with an initialization vector using SHA256. When a user with the password needs to read the log, decipher_logs.py is run with arguments including the channel name and the password. The channel name is used for lookup, and the password is used to generate the same key with the salt (IV) stored in the log, and then such key is used for decryption.
- We store and manage the symmetric key in a config file, and add that config file to .gitignore so that only those who have the config file locally can encrypt/decrypt the log files.
- For encryption, I use Fernet symmetric encryption scheme, generated using a private 128-bit key for encryption, and os.urandom() for initialization vectors. Fernet uses block cipher mode, which is believed to be safe. For authentication, I use HMAC (hash-based MAC) which uses SHA256 for hashing.
- To prevent known plaintext attacks, we randomize the salt used together with the private password to generate different keys every time. Therefore, the same text is always encrypted differently.
- For authentication, we write a MAC at the end of each log file, which can be verified using the key generated by the password and the randomized salt, together with the encrypted log. Therefore, if the log is modified in any way, an exception is thrown.
- Our crypto does protect against known plaintext attacks, chosen plaintext attacks and chosen ciphertext attacks.

Part 4:
- Syntax for file exchange:  
    `/getfiles <channel_or_username>`  
    `/download <channel_or_username>`  
            . Type the name of a file you would like to download:  
            . `<filepath>`  
    `/upload <channel_or_username>`  
            . Type the name of a file you would like to upload:  
            . `<filepath>`  
    `/update <channel_or_username>`  
            . Type the name of a file you would like to update:  
            . `<filepath>`  
    `/remove <channel_or_username>`  
            . Type the name of a file you would like to remove:  
            . `<filepath>`  
- We use AES encryption with PyCrypto. This is symmetric cryptography, and the IV is randomly generated for every new encryption and can be stored together with the ciphertext. This does not make our program susceptible to plaintext attacks if we do not use the same IV and the same encryption key for multiple encryptions.  

Part 5:
- We choose to use a hybrid cryptography implementation. The library we are using is nacl.box.

- We are not using key exchange because the two sides do not negotiate a key for decryption and encryption.

- Concern of algorithm:
  - Person-in-the-middle Attacks
    - Key exchange: Suppose there are two people: A, B, trying to establish a conversation. A person in the middle can get both public keys from A and B, and might even be able to modify the public key that A and B send to each other. Therefore for exchanging keys, the users need to trust the server for integrity and authentication. The public key is sent over through the server in plaintext. However since public keys of users are open to the public anyways, there is no need to encrypt the public keys during exchanging.
    - Sending messages: Suppose Alice and Bob have successfully exchanged their public keys and are now chatting. When Bob sends a message to Alice, Bob will first generate a box offline using his private key, which is always kept secret, and uses Alice's public key that he received to create a box. Next he will encrypt the message he wants to send using the box he created. If anyone who is sitting in the middle of the conversation between Alice and Bob has modified the encrypted messages sent over, Alice will not be able to decrypt the message, thus proving the encrypted messages sent by Bob is either invalid or modified. Therefore person-in-the-middle attack is prevented in this sense.
  - Replay attack:
    - Our implementation generates a new box with a randomized nonce each time Bob is sending a new messages to Alice (and vice versa), therefore replay attacks will be hard to perform since the same text will be encrypted to different cipher texts of different length each time.

- Real World Implementation
  - In real world scenarios, one challenge is that it is possible that some people sitting in the middle of the connection are able to modify the public key, as we stated above. Also, if the server through which we send over the public key is not trusted, then this implementation will be hard to achieve. We can surely using some other scheme to encrypt and sign the public key before sending over, however there might be some weakness and overheads of those cryptography schemes as well. 

Part 6: Our analysis for each part is included at the end of each writeup.
